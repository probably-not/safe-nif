defmodule SafeNIF.Bench.PortWrapper do
  @moduledoc false
  # CLI-based wrapper that spawns a fresh process per call.
  # Provides the same isolation model as SafeNIF (new process per call).
  # Generated by Claude and reviewed by @probably-not.

  @doc """
  Returns the path to the port executable.
  """
  def port_path do
    :safe_nif
    |> :code.priv_dir()
    |> :filename.join(~c"test_port")
    |> to_string()
  end

  @doc "Returns :ok - minimal round-trip with process spawn"
  def noop do
    case System.cmd(port_path(), ["noop"], stderr_to_stdout: true) do
      {"ok", 0} -> :ok
      {error, code} -> {:error, {code, error}}
    end
  end

  @doc "Adds two integers"
  def add(a, b) do
    case System.cmd(port_path(), ["add", to_string(a), to_string(b)], stderr_to_stdout: true) do
      {result, 0} -> String.to_integer(result)
      {error, code} -> {:error, {code, error}}
    end
  end

  @doc "Echoes data back - for testing payload sizes"
  def echo(data) when is_binary(data) do
    port =
      Port.open({:spawn_executable, port_path()}, [
        :binary,
        :exit_status,
        {:args, ["echo"]}
      ])

    # Send 4-byte big-endian length prefix, then data
    len = byte_size(data)
    Port.command(port, <<len::32-big, data::binary>>)

    collect_until_exit(port, [])
  end

  defp collect_until_exit(port, acc) do
    receive do
      {^port, {:data, chunk}} ->
        collect_until_exit(port, [chunk | acc])

      {^port, {:exit_status, 0}} ->
        acc |> Enum.reverse() |> IO.iodata_to_binary()

      {^port, {:exit_status, code}} ->
        {:error, code}
    after
      5000 -> {:error, :timeout}
    end
  end
end
