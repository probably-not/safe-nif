// Port executable that mirrors the test NIF functions
// Communicates via length-prefixed binary protocol over stdio
//
// Protocol:
//   Request:  <<length:32-big, command:8, payload...>>
//   Response: <<length:32-big, status:8, payload...>>
//
// Commands:
//   0x01 = noop      -> returns "ok"
//   0x02 = add(a,b)  -> returns a+b as 32-bit int
//   0x03 = echo(data)-> returns data back (for payload size testing)
// Generated by Claude and reviewed by @probably-not.

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

#define CMD_NOOP  0x01
#define CMD_ADD   0x02
#define CMD_ECHO  0x03

#define STATUS_OK    0x00
#define STATUS_ERROR 0x01

// Read exactly n bytes from stdin
static int read_exact(unsigned char *buf, size_t n) {
    size_t got = 0;
    while (got < n) {
        ssize_t r = read(STDIN_FILENO, buf + got, n - got);
        if (r <= 0) return -1;
        got += r;
    }
    return 0;
}

// Write exactly n bytes to stdout
static int write_exact(const unsigned char *buf, size_t n) {
    size_t written = 0;
    while (written < n) {
        ssize_t w = write(STDOUT_FILENO, buf + written, n - written);
        if (w <= 0) return -1;
        written += w;
    }
    return 0;
}

// Read a 32-bit big-endian length
static int read_length(uint32_t *len) {
    unsigned char buf[4];
    if (read_exact(buf, 4) < 0) return -1;
    *len = ((uint32_t)buf[0] << 24) |
           ((uint32_t)buf[1] << 16) |
           ((uint32_t)buf[2] << 8) |
           (uint32_t)buf[3];
    return 0;
}

// Write response with length prefix
static int write_response(uint8_t status, const unsigned char *payload, uint32_t payload_len) {
    uint32_t total_len = 1 + payload_len;  // status + payload
    unsigned char header[5];
    header[0] = (total_len >> 24) & 0xFF;
    header[1] = (total_len >> 16) & 0xFF;
    header[2] = (total_len >> 8) & 0xFF;
    header[3] = total_len & 0xFF;
    header[4] = status;

    if (write_exact(header, 5) < 0) return -1;
    if (payload_len > 0 && write_exact(payload, payload_len) < 0) return -1;
    return 0;
}

static void handle_noop(void) {
    unsigned char payload[] = "ok";
    write_response(STATUS_OK, payload, 2);
}

static void handle_add(const unsigned char *data, uint32_t len) {
    if (len < 8) {
        write_response(STATUS_ERROR, (unsigned char*)"bad args", 8);
        return;
    }

    int32_t a = ((int32_t)data[0] << 24) |
                ((int32_t)data[1] << 16) |
                ((int32_t)data[2] << 8) |
                (int32_t)data[3];

    int32_t b = ((int32_t)data[4] << 24) |
                ((int32_t)data[5] << 16) |
                ((int32_t)data[6] << 8) |
                (int32_t)data[7];

    int32_t result = a + b;
    unsigned char response[4];
    response[0] = (result >> 24) & 0xFF;
    response[1] = (result >> 16) & 0xFF;
    response[2] = (result >> 8) & 0xFF;
    response[3] = result & 0xFF;

    write_response(STATUS_OK, response, 4);
}

static void handle_echo(const unsigned char *data, uint32_t len) {
    write_response(STATUS_OK, data, len);
}

int main(int argc, char *argv[]) {
    // Disable buffering
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    while (1) {
        uint32_t len;
        if (read_length(&len) < 0) break;
        if (len == 0) continue;

        unsigned char *buf = malloc(len);
        if (!buf) break;

        if (read_exact(buf, len) < 0) {
            free(buf);
            break;
        }

        uint8_t cmd = buf[0];
        unsigned char *payload = buf + 1;
        uint32_t payload_len = len - 1;

        switch (cmd) {
            case CMD_NOOP:
                handle_noop();
                break;
            case CMD_ADD:
                handle_add(payload, payload_len);
                break;
            case CMD_ECHO:
                handle_echo(payload, payload_len);
                break;
            default:
                write_response(STATUS_ERROR, (unsigned char*)"unknown", 7);
                break;
        }

        free(buf);
    }

    return 0;
}