// Port CLI executable that mirrors the test NIF functions
// Spawned fresh for each call (like SafeNIF spawns a fresh peer node)
//
// Usage:
//   test_port noop           -> prints "ok"
//   test_port add <a> <b>    -> prints result
//   test_port echo           -> reads 4-byte length + data from stdin, echoes data to stdout
// Generated by Claude and reviewed by @probably-not.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static int cmd_noop(void)
{
    printf("ok");
    return 0;
}

static int cmd_add(int argc, char *argv[])
{
    if (argc < 4)
    {
        fprintf(stderr, "usage: test_port add <a> <b>\n");
        return 1;
    }
    int a = atoi(argv[2]);
    int b = atoi(argv[3]);
    printf("%d", a + b);
    return 0;
}

static int cmd_echo(void)
{
    // Read 4-byte big-endian length, then data, then echo back
    unsigned char len_buf[4];
    if (fread(len_buf, 1, 4, stdin) != 4)
    {
        return 1;
    }

    size_t len = ((size_t)len_buf[0] << 24) |
                 ((size_t)len_buf[1] << 16) |
                 ((size_t)len_buf[2] << 8) |
                 (size_t)len_buf[3];

    if (len > 1024 * 1024)
    { // 1MB max
        return 1;
    }

    unsigned char *buf = malloc(len);
    if (!buf)
    {
        return 1;
    }

    if (fread(buf, 1, len, stdin) != len)
    {
        free(buf);
        return 1;
    }

    fwrite(buf, 1, len, stdout);
    fflush(stdout);
    free(buf);
    return 0;
}

int main(int argc, char *argv[])
{
    if (argc < 2)
    {
        fprintf(stderr, "usage: test_port <command> [args...]\n");
        fprintf(stderr, "commands: noop, add, echo\n");
        return 1;
    }

    const char *cmd = argv[1];

    if (strcmp(cmd, "noop") == 0)
    {
        return cmd_noop();
    }
    else if (strcmp(cmd, "add") == 0)
    {
        return cmd_add(argc, argv);
    }
    else if (strcmp(cmd, "echo") == 0)
    {
        return cmd_echo();
    }
    else
    {
        fprintf(stderr, "unknown command: %s\n", cmd);
        return 1;
    }
}