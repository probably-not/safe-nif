// Minimal NIF that provides various crash modes for testing SafeNIF
// This NIF is intentionally dangerous - it exists only to validate crash isolation
// Generated by Claude and reviewed by @probably-not.

#include <erl_nif.h>
#include <stdlib.h>
#include <string.h>

// Crash via null pointer dereference (SIGSEGV)
static ERL_NIF_TERM
crash_segfault(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    volatile int* ptr = NULL;
    *ptr = 42;  // Write to null - guaranteed SIGSEGV
    return enif_make_atom(env, "ok");  // Never reached
}

// Crash via abort() (SIGABRT)
static ERL_NIF_TERM
crash_abort(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    abort();
    return enif_make_atom(env, "ok");  // Never reached
}

// Crash via stack overflow - prevent tail-call optimization
static volatile int stack_overflow_dummy;

static int infinite_recursion(int depth) {
    volatile char buffer[8192];  // Large buffer to eat stack fast
    buffer[0] = depth & 0xFF;
    buffer[8191] = depth & 0xFF;
    stack_overflow_dummy = infinite_recursion(depth + 1);
    return stack_overflow_dummy + buffer[0];  // Use result to prevent optimization
}

static ERL_NIF_TERM
crash_stack_overflow(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    int result = infinite_recursion(0);
    return enif_make_int(env, result);  // Never reached
}

// Crash via division by zero (SIGFPE on some platforms)
static ERL_NIF_TERM
crash_div_zero(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    volatile int zero = 0;
    volatile int result = 1 / zero;
    return enif_make_int(env, result);
}

// A safe function that returns :ok (for comparison)
static ERL_NIF_TERM
safe_noop(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    return enif_make_atom(env, "ok");
}

// A safe function that does some work and returns a value
static ERL_NIF_TERM
safe_add(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    int a, b;
    if (!enif_get_int(env, argv[0], &a) || !enif_get_int(env, argv[1], &b)) {
        return enif_make_badarg(env);
    }
    return enif_make_int(env, a + b);
}

// Echo binary data back - for payload size benchmarks
static ERL_NIF_TERM
safe_echo(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    ErlNifBinary bin;
    if (!enif_inspect_binary(env, argv[0], &bin)) {
        return enif_make_badarg(env);
    }
    // Return the same binary (no copy needed, just return the term)
    return argv[0];
}

static ErlNifFunc nif_funcs[] = {
    {"crash_segfault", 0, crash_segfault},
    {"crash_abort", 0, crash_abort},
    {"crash_stack_overflow", 0, crash_stack_overflow},
    {"crash_div_zero", 0, crash_div_zero},
    {"safe_noop", 0, safe_noop},
    {"safe_add", 2, safe_add},
    {"safe_echo", 1, safe_echo}
};

ERL_NIF_INIT(Elixir.SafeNIFTest.TestNIF, nif_funcs, NULL, NULL, NULL, NULL)