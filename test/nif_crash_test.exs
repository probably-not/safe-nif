defmodule SafeNIF.NIFCrashTest do
  use ExUnit.Case, async: false

  alias SafeNIFTest.TestNIF

  @moduletag timeout: 10_000

  # Tests Generated by Claude, reviewed by @probably-not

  setup_all do
    case TestNIF.load_nif() do
      :ok ->
        :ok

      {:error, reason} ->
        IO.puts("\n⚠️  Skipping NIF crash tests - NIF not compiled")
        IO.puts("   Run 'make' to compile the test NIF")
        IO.puts("   Error: #{inspect(reason)}\n")
        :skip
    end
  end

  describe "NIF crash isolation" do
    @tag :nif_crash
    test "segfault crash is isolated" do
      main_node = node()
      main_pid = self()

      result = SafeNIF.wrap({TestNIF, :crash_segfault, []}, to_timeout(second: 10))

      assert node() == main_node
      assert self() == main_pid
      assert Node.alive?()

      assert {:error, reason} = result
      assert reason in [:noconnection, :noproc] or match?({:nodedown, _}, reason)
    end

    @tag :nif_crash
    test "abort crash is isolated" do
      main_node = node()

      result = SafeNIF.wrap({TestNIF, :crash_abort, []}, to_timeout(second: 10))

      assert node() == main_node
      assert Node.alive?()
      assert {:error, _reason} = result
    end

    @tag :nif_crash
    test "stack overflow crash is isolated" do
      main_node = node()

      result = SafeNIF.wrap({TestNIF, :crash_stack_overflow, []}, to_timeout(second: 10))

      assert node() == main_node
      assert Node.alive?()
      assert {:error, _reason} = result
    end

    @tag :nif_crash
    test "division by zero is isolated" do
      main_node = node()

      result = SafeNIF.wrap({TestNIF, :crash_div_zero, []}, to_timeout(second: 10))

      assert node() == main_node
      assert Node.alive?()
      assert match?({:ok, _}, result) or match?({:error, _}, result)
    end
  end

  describe "safe NIF functions work correctly" do
    @tag :nif_safe
    test "safe_noop returns :ok" do
      assert {:ok, :ok} = SafeNIF.wrap({TestNIF, :safe_noop, []})
    end

    @tag :nif_safe
    test "safe_add returns correct result" do
      assert {:ok, 42} = SafeNIF.wrap({TestNIF, :safe_add, [17, 25]})
    end

    @tag :nif_safe
    test "safe functions are much faster than crashes" do
      results =
        for _ <- 1..5 do
          SafeNIF.wrap({TestNIF, :safe_add, [1, 2]})
        end

      assert Enum.all?(results, &match?({:ok, 3}, &1))
    end
  end

  describe "mixed workloads" do
    @tag :nif_crash
    test "crash doesn't affect subsequent safe calls" do
      {:error, _} = SafeNIF.wrap({TestNIF, :crash_segfault, []}, to_timeout(second: 10))
      assert {:ok, :ok} = SafeNIF.wrap({TestNIF, :safe_noop, []})
      assert {:ok, 10} = SafeNIF.wrap({TestNIF, :safe_add, [3, 7]})
    end

    @tag :nif_crash
    test "concurrent crash and safe calls" do
      tasks = [
        Task.async(fn -> SafeNIF.wrap({TestNIF, :safe_add, [1, 1]}, to_timeout(second: 15)) end),
        Task.async(fn -> SafeNIF.wrap({TestNIF, :crash_segfault, []}, to_timeout(second: 15)) end),
        Task.async(fn -> SafeNIF.wrap({TestNIF, :safe_add, [2, 2]}, to_timeout(second: 15)) end)
      ]

      results = Task.await_many(tasks, 30_000)

      assert {:ok, 2} = Enum.at(results, 0)
      assert {:ok, 4} = Enum.at(results, 2)
      assert {:error, _} = Enum.at(results, 1)
      assert Node.alive?()
    end
  end
end
