defmodule SafeNIFTest do
  use ExUnit.Case, async: false

  alias SafeNIFTest.Helpers

  doctest SafeNIF

  # Tests Generated by Claude, reviewed by @probably-not

  @moduletag timeout: 10_000

  describe "basic functionality" do
    test "MFA returns simple value" do
      assert {:ok, 42} = SafeNIF.wrap({Helpers, :return_42, []})
    end

    test "MFA with arguments" do
      assert {:ok, 6} = SafeNIF.wrap({Kernel, :+, [2, 4]})
    end

    test "MFA returns complex data structures" do
      expected = %{
        list: [1, 2, 3],
        tuple: {:ok, "value"},
        nested: %{deep: [a: 1, b: 2]}
      }

      assert {:ok, ^expected} = SafeNIF.wrap({Helpers, :return_complex_data, []})
    end

    test "MFA returns large binaries" do
      size = 1_000_000

      assert {:ok, result} = SafeNIF.wrap({Helpers, :return_large_binary, [size]}, 30_000)
      assert byte_size(result) == size
    end

    test "MFA with zero arity returns peer node name" do
      assert {:ok, result} = SafeNIF.wrap({Helpers, :return_self_node, []})

      assert result != node()
      assert is_atom(result)
    end

    test "function return value is wrapped regardless of shape" do
      assert {:ok, {:error, :oops}} = SafeNIF.wrap({Helpers, :return_value, [{:error, :oops}]})
      assert {:ok, :error} = SafeNIF.wrap({Helpers, :return_value, [:error]})
      assert {:ok, nil} = SafeNIF.wrap({Helpers, :return_value, [nil]})
    end
  end

  describe "timeout handling" do
    test "returns timeout error when function exceeds timeout" do
      result = SafeNIF.wrap({Helpers, :sleep_forever, []}, 500)
      assert {:error, :timeout} = result
    end

    test "timeout returns promptly without hanging" do
      {time_us, result} = :timer.tc(fn -> SafeNIF.wrap({Helpers, :sleep_forever, []}, 500) end)
      assert {:error, :timeout} = result
      assert time_us < 2_000_000
    end

    test "cleanup occurs after timeout" do
      SafeNIF.wrap({Helpers, :sleep_forever, []}, 200)
      Process.sleep(500)
      assert %{active: 0} = DynamicSupervisor.count_children(SafeNIF.DynamicSupervisor)
    end

    test "custom timeout is respected" do
      start = System.monotonic_time(:millisecond)
      SafeNIF.wrap({Helpers, :sleep_forever, []}, 1_000)
      elapsed = System.monotonic_time(:millisecond) - start

      assert elapsed >= 1_000
      assert elapsed < 2_000
    end
  end

  describe "exception handling" do
    test "raised exception returns error tuple" do
      result = SafeNIF.wrap({Helpers, :raise_error, ["boom"]})

      assert {:error, reason} = result
      assert reason != :normal
    end

    test "throw is captured" do
      result = SafeNIF.wrap({Helpers, :throw_value, [:caught_this]})
      assert {:error, _reason} = result
    end

    test "exit is captured" do
      result = SafeNIF.wrap({Helpers, :exit_with, [:deliberate]})
      assert {:error, :deliberate} = result
    end

    test "function clause error is captured" do
      result = SafeNIF.wrap({String, :to_integer, ["not_a_number"]})
      assert {:error, _reason} = result
    end
  end

  describe "node crash isolation" do
    test "erlang:halt on peer does not crash main node" do
      main_node = node()
      main_pid = self()
      result = SafeNIF.wrap({Helpers, :halt_node, [1]}, 15_000)

      assert node() == main_node
      assert self() == main_pid
      assert Node.alive?()

      assert {:error, reason} = result
      assert reason in [:noconnection, :noproc] or match?({:nodedown, _}, reason)
    end

    test "erlang:halt with different exit codes" do
      for code <- [0, 1, 42, 255] do
        result = SafeNIF.wrap({Helpers, :halt_node, [code]}, 15_000)
        assert {:error, _} = result
        assert Node.alive?()
      end
    end

    test "peer node is cleaned up after crash" do
      hidden_before = Node.list(:hidden)
      SafeNIF.wrap({Helpers, :halt_node, [1]}, 15_000)
      Process.sleep(500)
      hidden_after = Node.list(:hidden)

      new_peers = hidden_after -- hidden_before
      assert new_peers == []
    end

    test "multiple sequential crashes don't leak nodes" do
      hidden_before = Node.list(:hidden)

      for _ <- 1..5 do
        SafeNIF.wrap({Helpers, :halt_node, [1]}, 15_000)
      end

      Process.sleep(500)

      hidden_after = Node.list(:hidden)
      new_peers = hidden_after -- hidden_before
      assert new_peers == []
    end

    test "main node services continue working after peer crash" do
      {:ok, agent} = Agent.start_link(fn -> 0 end)
      SafeNIF.wrap({Helpers, :halt_node, [1]}, 15_000)

      assert Agent.get(agent, & &1) == 0
      assert :ok = Agent.update(agent, &(&1 + 1))
      assert Agent.get(agent, & &1) == 1

      Agent.stop(agent)
    end
  end

  describe "hidden nodes" do
    test "peer nodes are hidden from Node.list/0" do
      visible_before = Node.list()
      task = Task.async(fn -> SafeNIF.wrap({Helpers, :sleep_ms, [3_000]}, 10_000) end)
      Process.sleep(1_500)
      visible_during = Node.list()

      assert visible_during -- visible_before == []

      Task.await(task, 15_000)
    end

    test "peer nodes appear in Node.list(:hidden)" do
      hidden_before = Node.list(:hidden)
      task = Task.async(fn -> SafeNIF.wrap({Helpers, :sleep_ms, [3_000]}, 10_000) end)
      Process.sleep(1_500)
      hidden_during = Node.list(:hidden)

      new_hidden = hidden_during -- hidden_before
      assert [_ | _] = new_hidden

      Task.await(task, 15_000)
    end

    test "peer nodes don't trigger standard net_kernel monitors" do
      :net_kernel.monitor_nodes(true)
      flush_nodeup_messages()
      task = Task.async(fn -> SafeNIF.wrap({Helpers, :sleep_ms, [2_000]}, 10_000) end)
      Process.sleep(1_500)

      refute_received {:nodeup, _}

      Task.await(task, 15_000)

      :net_kernel.monitor_nodes(false)
      flush_nodeup_messages()
    end

    test "peer nodes do trigger monitors with node_type: :all" do
      :net_kernel.monitor_nodes(true, node_type: :all)
      flush_node_messages()

      _result = SafeNIF.wrap({Helpers, :return_42, []}, 15_000)

      assert_received {:nodeup, _node, _info}

      :net_kernel.monitor_nodes(false, node_type: :all)
      flush_node_messages()
    end
  end

  describe "concurrency" do
    test "multiple concurrent calls succeed" do
      tasks =
        for i <- 1..10 do
          Task.async(fn -> SafeNIF.wrap({Helpers, :multiply, [i, 2]}, 30_000) end)
        end

      results = Task.await_many(tasks, 60_000)

      assert length(results) == 10
      assert Enum.all?(results, &match?({:ok, _}, &1))

      values = results |> Enum.map(fn {:ok, v} -> v end) |> Enum.sort()
      assert values == [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
    end

    test "concurrent calls with mixed success and timeout" do
      tasks = [
        Task.async(fn -> SafeNIF.wrap({Helpers, :return_value, [:fast]}, 10_000) end),
        Task.async(fn -> SafeNIF.wrap({Helpers, :sleep_forever, []}, 500) end),
        Task.async(fn -> SafeNIF.wrap({Helpers, :return_value, [:also_fast]}, 10_000) end)
      ]

      results = Task.await_many(tasks, 30_000)

      assert {:ok, :fast} = Enum.at(results, 0)
      assert {:error, :timeout} = Enum.at(results, 1)
      assert {:ok, :also_fast} = Enum.at(results, 2)
    end

    test "concurrent calls with some crashes" do
      tasks = [
        Task.async(fn -> SafeNIF.wrap({Helpers, :return_value, [:ok]}, 15_000) end),
        Task.async(fn -> SafeNIF.wrap({Helpers, :halt_node, [1]}, 15_000) end),
        Task.async(fn -> SafeNIF.wrap({Helpers, :return_value, [:also_ok]}, 15_000) end)
      ]

      results = Task.await_many(tasks, 60_000)

      assert {:ok, :ok} = Enum.at(results, 0)
      assert {:error, _} = Enum.at(results, 1)
      assert {:ok, :also_ok} = Enum.at(results, 2)
    end

    test "no runner leak after concurrent operations" do
      tasks =
        for _ <- 1..20 do
          Task.async(fn -> SafeNIF.wrap({Helpers, :return_42, []}, 15_000) end)
        end

      Task.await_many(tasks, 120_000)
      Process.sleep(1_000)

      assert %{active: 0} = DynamicSupervisor.count_children(SafeNIF.DynamicSupervisor)
    end
  end

  describe "supervisor" do
    test "runner processes are managed by dynamic supervisor" do
      %{active: initial} = DynamicSupervisor.count_children(SafeNIF.DynamicSupervisor)
      task = Task.async(fn -> SafeNIF.wrap({Helpers, :sleep_ms, [3_000]}, 10_000) end)
      Process.sleep(1_500)
      %{active: during} = DynamicSupervisor.count_children(SafeNIF.DynamicSupervisor)

      assert during > initial

      Task.await(task, 15_000)

      Process.sleep(500)

      %{active: after_} = DynamicSupervisor.count_children(SafeNIF.DynamicSupervisor)
      assert after_ == initial
    end

    test "killing a runner doesn't crash the supervisor" do
      sup_pid = Process.whereis(SafeNIF.DynamicSupervisor)
      assert Process.alive?(sup_pid)
      task = Task.async(fn -> SafeNIF.wrap({Helpers, :sleep_ms, [10_000]}, 15_000) end)
      Process.sleep(1_500)

      children = DynamicSupervisor.which_children(SafeNIF.DynamicSupervisor)
      assert [_ | _] = children

      [{_, runner_pid, _, _} | _] = children
      Process.exit(runner_pid, :kill)
      Process.sleep(500)

      assert Process.alive?(sup_pid)
      assert {:error, _} = Task.await(task, 5_000)
    end
  end

  describe "code loading on peer" do
    test "peer can execute standard library functions" do
      result = SafeNIF.wrap({Keyword, :get, [[a: 1, b: 2], :a]})
      assert {:ok, 1} = result
    end

    test "peer can use Enum module" do
      result = SafeNIF.wrap({Helpers, :enum_sum, [[1, 2, 3, 4, 5]]})
      assert {:ok, 15} = result
    end

    test "peer can use :crypto" do
      result = SafeNIF.wrap({Helpers, :crypto_hash, [:sha256, "test"]})
      assert {:ok, hash} = result
      assert is_binary(hash)
      assert byte_size(hash) == 32
    end

    test "peer has access to application config" do
      Application.put_env(:safe_nif, :test_key, :test_value)
      result = SafeNIF.wrap({Helpers, :get_app_env, [:safe_nif, :test_key]}, 15_000)
      assert {:ok, :test_value} = result
      Application.delete_env(:safe_nif, :test_key)
    end
  end

  describe "edge cases" do
    test "function returning nil" do
      assert {:ok, nil} = SafeNIF.wrap({Helpers, :return_value, [nil]})
    end

    test "function returning pid from peer" do
      result = SafeNIF.wrap({Helpers, :return_self_pid, []})
      assert {:ok, pid} = result
      assert is_pid(pid)
      assert node(pid) != node()
    end

    test "function returning reference from peer" do
      result = SafeNIF.wrap({Helpers, :return_make_ref, []})
      assert {:ok, ref} = result
      assert is_reference(ref)
    end

    test "rapid sequential calls" do
      results =
        for i <- 1..10 do
          SafeNIF.wrap({Helpers, :return_value, [i]}, 15_000)
        end

      assert Enum.all?(results, &match?({:ok, _}, &1))
      values = Enum.map(results, fn {:ok, v} -> v end)
      assert values == Enum.to_list(1..10)
    end

    test "very short timeout" do
      result = SafeNIF.wrap({Helpers, :sleep_ms, [1_000]}, 1)
      assert {:error, :timeout} = result
    end

    test "function that spawns processes on peer" do
      result = SafeNIF.wrap({Helpers, :spawn_processes, [10]}, 15_000)
      assert {:ok, 10} = result
    end
  end

  describe "telemetry" do
    test "supervisor count emits telemetry" do
      ref = make_ref()
      test_pid = self()

      handler = fn event, measurements, _metadata, _config ->
        send(test_pid, {ref, event, measurements})
      end

      :telemetry.attach("test-handler-#{inspect(ref)}", [:safe_nif, :supervisor], handler, nil)

      SafeNIF.DynamicSupervisor.count()

      assert_receive {^ref, [:safe_nif, :supervisor], measurements}
      assert is_map(measurements)
      assert Map.has_key?(measurements, :active)
      assert Map.has_key?(measurements, :supervisors)
      assert Map.has_key?(measurements, :workers)

      :telemetry.detach("test-handler-#{inspect(ref)}")
    end
  end

  defp flush_nodeup_messages do
    receive do
      {:nodeup, _} -> flush_nodeup_messages()
      {:nodedown, _} -> flush_nodeup_messages()
    after
      0 -> :ok
    end
  end

  defp flush_node_messages do
    receive do
      {:nodeup, _, _} -> flush_node_messages()
      {:nodedown, _, _} -> flush_node_messages()
      {:nodeup, _} -> flush_node_messages()
      {:nodedown, _} -> flush_node_messages()
    after
      0 -> :ok
    end
  end
end
